# 算法导论笔记
## 1.1 算法
**算法**(algorithm)就是人和良定义的计算过程，该过程取某个值或值的集合作为**输入**并产生某个值或值的集合作为**输出**。  
**实例**(instance)由计算该问题解所必须的(满足问题陈述中强加的各种约束)输入组成。
若对每个输入实例，算法都以正确的输出停机，则称该算法是*正确的*，并称正确的算法*解决了*给定的计算问题。  

许多有趣的算法问题所共有的两个特征:
1. 存在许多候选解，但绝大多数候选解都没有解决手头的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。
2. 存在实际应用。  

**数据结构**  
是一种储存和组织数据的方式，旨在便于访问和修改。没有一种单一的数据结构对所有用途均有效，所以重要的是知道几种数据结构的优势和局限。  

## 2.1 插入排序
插入排序求解**排序问题**
输入: n个书的一个序列<a1, a2, ..., an>
输出: 输入序列的一个排列<a'1, a'2, ..., a'n>, 满足a'1≤a'2≤...≤a'n
对于少量元素的排序，插入排序是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始是，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中的正确位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。那在左手上的牌总是排序好的，原来这些牌是桌子上排队中顶部的牌。  
对于插入排序，我们将其伪代码过程命名为**INSERTION-SORT**，其中的参数是一个数组A[1..n]，包含张度为你的要排序的一个序列。(在代码中，A中元素的数目n用A.length来表示)该算法**原址**排序输入的数：算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。在过程INSERTION-SORT结束时，输入数组A包含排序好的输出序列。
```
for j = 2 to A.length
	key = A[j]
	i = j - 1
	while i > 0 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i+1] = key
```
我们把A[j-1]的这些性质形式地表示为一个**循环不变式**。  
循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质: 
	**初始化**：循环的第一次迭代之前，它为真。  
	**保持** ： 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。  
	**终止**：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。  
当前两条性质成立时，在循环的每次迭代之前循环不变式为真。(当然，为了证明循环不变式在每次迭代之前保持为真，我们完全可以使用不同于循环不变式本身的其他已证实的事实)。  
第三条性质也许是最重要的，因为我们将使用循环不变式来证明正确性。通常，我们和导致循环终止的条件一起使用循环不变式。终止性不同于我们通常是用数学归纳法的做法，在归纳法中，归纳步是无限地使用的，这里当循环终止时，停止*归纳*

## 2.2分析算法
我们假定一种通用的单处理器计算模型——随机访问机(random-access machine, RAM)来作为我们的实现技术，算法可以用计算机程序来实现。在RAM模型中，指令一条接一条地执行，没有并发操作。当x y都是实数时，计算x<sup>y</sup>需要若干条指令。然而，在受限情况下，指数运算又是一个常量时间的操作。许多计算机都有“左移”指令，他在常量时间内将一个整数的各位向左移k位。在大多数计算机中，将一个整数的各位向左移一位等价于将该整数乘以2，结果将一个整数的各位向左移k位等价于将该整数乘以2<sup>k</sup>。所以，只要k不大于一个计算机字中的位数，这样的计算机就可以由一条常量时间的指令来计算2<sup>k</sup>，即将整数1向左移k位。所以当k是一个足够小的整数时，我们将把2<sup>k</sup>的计算堪称一个常量的操作。  
#### 插入排序算法的分析
插入算法需要的时间依赖于输入，排序1000个数比排序三个数需要更长的时间。此外，依据它们已被排序的程度，插入算法可能需要不同数量的时间来排序两个具有相同规模的输入序列。一般来说，算法需要的时间与输入的规模的同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。  
#### 输入规模
输入规模的最佳概念依赖于研究的问题。对许多问题，如排序或计算离散傅立叶变换，最自然的度量是输入中的*项数*。  
#### 最坏与平均情况分析
我们往往集中于只研究**最坏情况运行时间**，即对规模为n的任何输入，算法的最长运行时间。下面给出这样做的三点理由: 
* 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。我们不必对运行时间做某种复杂的猜测并可以期望他不会变的更坏。  
* 对某些算法，最坏情况经常出现。例如，当数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况经常会出现。在某些应用中，对确实信息的检索可能是频繁的。
* “平均情况”往往与最坏情况大致一样差。嘉定随机选择n个数并应用插入排序。需要更长时间来确定在子数组A[1..j-1]的什么位置插入元素A[j]?平均来说，A[1..j-1]中的一半元素小于A[j]， 一半元素大雨A[j]。所以，平均来说，我们检查自数组A[1..j-1]的一半，那么t<sub>j</sub>大约为j/2。导致平均情况运行时间结果像最坏情况运行时间一样。也是输入规模的一个二次函数。  

在某些特定情况下，我们会对一个算法的**平均情况**运行时间感兴趣；我们将看到**概率分析**技术被用于各种算法。平均情况分析的范围有限，因为对于特定的问题，什么构成一种“平均”输入并不明显。我们常常假定给定规模的所有输入具有相同的可能性。实际上，该假设可能不成立，但是，有时可以使用**随机化算法**，他做出一些随机的选择，以允许进行概率分析并产生某个**期望**的运行时间。  
#### 增长量级
我们使用某些简化的抽象来使过程的分析更加容易。首先，通过使用常量c<sub>i</sub>，表示这些代价来忽略每条语句的实际代价。其次，注意到这些常量也提供了比我们真正需要的要多的细节：把最坏的情况运行时间表示为an^2+bn+c，其中常量a、b和c依赖于语句代价c<sub>i</sub>。这样，我们不但忽略实际的语句代价，而且也忽略抽象的代价c<sub>i</sub>。  
即我们真正感兴趣的运行时间的**增长率**或**增长量级**。所以我们只考虑公式中最重要的项，因为当n的值很大时，低阶项相对来说不太重要。我们也忽略最重要的项的常系数，因为对大的输入，在确定计算效率时常量因子不如增长率重要。  
如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么我们通常认为前者比后者更有效。由于常量因子和低阶项，对于小的输入，运行时间具有较高增长量级的一个算法与运行时间有较低增长量级的另一个算法相比，其可能需要较少的时间。但是对足够大的输入，在最坏的情况下运行得更快。  

## 2.3 分治法
许多有用的算法在结构上是**递归的**: 为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干自问题。这些算法典型地遵循**分治法**的思想：将愿问题分解为几个规模较小单类似于原问题的子问题，递归地求解这些自问题，然后再合并这些子问题的解来建立愿问题的解。  
分治法在每层递归时都有三个步骤：  
	**分解**原问题为若干个子问题，这些子问题是原问题的规模较小的实例。  
	**解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。  
	**合并**这些子问题的解成原问题的解。  

**归并排序**算法完全遵循分治模式。直观上其操作如下：
	**分解**：分解待排序的n各元素的序列成各具n/2个元素的两个子序列。  
	**解决**：使用归并排序递归地排序两个子序列。  
	**合并**：合并两个已排序的子序列以产生已排序的答案。  
	当待排序的序列长度为1时，递归“开始回升”，在这种情况下不要做任何工作，因为长度为1的每个序列都已排好序。  
	下面的伪代码实现了上面的思想，但有一个额外的变化，以避免在每个基本步骤必须检查是否有堆为空。在每个堆的底部放置一张**哨兵**牌，这里我们使用∞作为哨兵值。结果每当显露一张值为∞的牌，它不可能为较小的牌，除非两个堆都已显露其哨兵牌。但是，一旦发生这种情况，所有非哨兵牌都已被放置到输出堆。  
```
MERGE(A, p, q, r)
n1 = q - p + 1
n2 = r - q
let L[1...n1+1] and R[1...n2+1] be new arrays
for i = 1 to n1
	L[i] = A[p + i - 1]
for j = 1 to n2
	R[j] = A[q + j]
L[n1 + 1] = ∞
R[n2 + 1] = ∞
i = 1
j = 1
for k = p to r
	if L[i] ≤ R[j]
		A[k] = L[i]
		i = i + 1
	else A[k] = R[j]
		j = j + 1
```
MERGE的运行时间是O(n)，现在我们可以把过程MERGE作为归并排序算法的一个子程序来用。下面的过程MERGE-SORT(A, p, r)排序自数组A[p..r]中的元素。若p≥r，则该子数组最多有一个元素，所以已经排好序。否则，分解步骤简单地计算一个下标q，将A[p..r]分成两个子数组A[p..q]和A[q+1..r]，前者包含前n/2个元素，后者包含后n/2个元素。

```
MERGE-SORT(A, p, r)
if p < r
	q = [(p+r)/2]
	MERGE-SORT(A, p, q)
	MERGE-SORT(A, q+1, r)
	MERGE(A, p, q, r)
```
### 分析分治算法
当一个算法包含对其自身的递归调用时，我们往往可以用**递归方程**或**递归式**来描述其运行时间。  
假设我们把愿问题分解成a个子问题，每个子问题的规模是原问题的1/b。为了求解一个规模为n/b的子问题需要T(n/b)的时间，所以需要aT(n/b)的时间来求解a个子问题。如果分解问题成子问题需要时间D(n)，合并子问题的解成原问题的解需要时间C(n)，那么递归式T(n)等于:   
\begin{array}{l}O\left(1\right)\;\;\;\;if\;n\mathrm{\le }c\\ aT(n/b)+D\left(n\right)+C\left(n\right)\;\;\;\;else\end{array}  
#### 归并排序算法的分析
**分解**：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此，D(n) = O(1)。  
**解决**：我们递归地求解两个规模均为n/2的子问题，将贡献2T(n/2)的运行时间。  
**合并**：我们应注意到在一个具有n个元素的子数组上过程MERGE需要O(n)的时间，所以C(n) = O(n)。  
\begin{array}{l}O\left(1\right)\;\;\;\;if\;n=1\\ 2T(n/2)+O\left(n\right)\;\;\;\;if\;n>1\end{array}  

## 3. 函数的增长
当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的**渐近**效率。也就是说，我们关系当输入规模无限增加时，*在极限中*，算法的运行时间如何随着输入规模的变大而增加。通常，渐近地更有效的某个算法对除很小的输入外所有的情况将是最好的选择。
### 3.1 渐近记号
**Θ记号**  
Θ(g(n)) = {f(n): 存在正常量c1, c2, n0, 使得对所有n ≥ n0，有0 ≤ c1g(n) ≤ f(n) ≤ c2g(n)}
**O记号（渐近上界）**  
O(g(n)) = {f(n): 存在正常量c和n0，使得对所有n≥n0，有0≤f(n)≤cg(n)}
**Ω记号（渐近下界）**  
Ω(g(n)) = {f(n): 存在正常量c和n0，使得对所有n≥n0，有0≤cg(n)≤f(n)}
###3.2标准记号与常用函数
**单调性**  
若m≤n蕴含f(m)≤f(n)，则函数f(n)是**单调递增**的。类似地，若m≤n蕴含f(m)≥f(n)，则函数f(n)是**单调递减**的。若m<n蕴含f(m)<f(n)，则函数f(n)是**严格递增**的。若m>n蕴含f(m)>f(n)，则函数f(n)是**严格递减**的。
**向下取整与向上取整**
对于任意实数x，我们用⌊x⌋表示小于或等于x的最大整数(读作"x的向下取整")，并用⌈x⌉表示大于或等于x的最小整数(读作"x的向上取整")。向下取整函数是单调递增的，向上取整函数也是单调递增的。
**斐波那契数**
F<sub>i</sub> = F<sub>i-1</sub> + F<sub>i-2</sub>  
斐波那契数与黄金分割率φ及其共轭数有关，它们是x<sup>2</sup> = x + 1的两个根。第i个斐波那契数F<sub>i</sub>等于φ<sup>i</sup>/sqrt(5)舍入到最近的整数。
# 4. 分治策略
当子问题足够大，需要递归求解时，我们称之为**递归情况**(recursive case)。 当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了**基本情况**(base case)。有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。我们将这些子问题的求解看作合并步骤的一部分。  
**递归式**  
递归式与分治方法是紧密相关的，因为使用递归式可以很自然地刻画分治算法的运行时间。一个**递归式**(recurrence)就是一个等式或不等式，它通过更小的输入上的函数值来描述一个函数。  
本章介绍三种求解递归的方法:  
* **代入法**  我们猜测一个界，然后用数学归纳法证明这个界是正确的。
*  **递归树法**  将递归是转换为一棵树，其节点白哦是不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。
*  **主方法**  可求解形如下面公式的递归式的界:  aT(n/b) + f(n)  
其中a≥1，b≥1，f(n)是一个给定的函数。这种形式的递归式很常见，它刻画了这样一个分治算法：生成a个子问题，每个子问题的规模是原问题的1/b，分解合并步骤总花费时间为f(n).
## 4.1 最大子数组问题
